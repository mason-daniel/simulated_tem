
    module Lib_MarchingCubes
!---^^^^^^^^^^^^^^^^^^^^^^^^
!*      based on the original
!*      Written by Paul Bourke
!*      May 1994
!*
!*      Based on tables by Cory Gene Bloyd along with
!*      additional example source code marchingsource.cpp
!*      http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise/
!*
!*      translated into Fortran by
!*      Daniel Mason
!*      January 2011

        use iso_fortran_env
        implicit none
        private

    !---
    
        public          ::      gridCell_ctor

        public          ::      Polygonize                  !   returns 0 - 5 triangles describing isosurface in a cube 
        public          ::      getNtriang                  !   how many triangles are needed to describe isosurface?                                                                


    !---

        type,public     ::      tri
            real(kind=real64),dimension(3,3)        ::      p            !   positions of vertices of triangle. p(1:3,1) is position of first vertex
        end type

        type,public     ::      gridcell
            private
            real(kind=real64),dimension(3,0:7)       ::      p           !   positions of corners of the cube. ( xyz , x'yz, x'y'z, xy'z , xyz' , x'yz', x'y'z', xy'z' )
            real(kind=real64),dimension(0:7)         ::      val         !   values at corners of the cube
        end type

    !---

        integer(kind=int32),dimension(0:255),parameter          ::                          &
                EDGETABLE = int( (/                                                         &
                    int(Z'0'  ), int(Z'109'), int(Z'203'), int(Z'30a'), int(Z'406'), int(Z'50f'), int(Z'605'), int(Z'70c'),         &
                    int(Z'80c'), int(Z'905'), int(Z'a0f'), int(Z'b06'), int(Z'c0a'), int(Z'd03'), int(Z'e09'), int(Z'f00'),         &
                    int(Z'190'), int(Z'99' ), int(Z'393'), int(Z'29a'), int(Z'596'), int(Z'49f'), int(Z'795'), int(Z'69c'),         &
                    int(Z'99c'), int(Z'895'), int(Z'b9f'), int(Z'a96'), int(Z'd9a'), int(Z'c93'), int(Z'f99'), int(Z'e90'),         &
                    int(Z'230'), int(Z'339'), int(Z'33' ), int(Z'13a'), int(Z'636'), int(Z'73f'), int(Z'435'), int(Z'53c'),         &
                    int(Z'a3c'), int(Z'b35'), int(Z'83f'), int(Z'936'), int(Z'e3a'), int(Z'f33'), int(Z'c39'), int(Z'd30'),         &
                    int(Z'3a0'), int(Z'2a9'), int(Z'1a3'), int(Z'aa' ), int(Z'7a6'), int(Z'6af'), int(Z'5a5'), int(Z'4ac'),         &
                    int(Z'bac'), int(Z'aa5'), int(Z'9af'), int(Z'8a6'), int(Z'faa'), int(Z'ea3'), int(Z'da9'), int(Z'ca0'),         &
                    int(Z'460'), int(Z'569'), int(Z'663'), int(Z'76a'), int(Z'66' ), int(Z'16f'), int(Z'265'), int(Z'36c'),         &
                    int(Z'c6c'), int(Z'd65'), int(Z'e6f'), int(Z'f66'), int(Z'86a'), int(Z'963'), int(Z'a69'), int(Z'b60'),         &
                    int(Z'5f0'), int(Z'4f9'), int(Z'7f3'), int(Z'6fa'), int(Z'1f6'), int(Z'ff' ), int(Z'3f5'), int(Z'2fc'),         &
                    int(Z'dfc'), int(Z'cf5'), int(Z'fff'), int(Z'ef6'), int(Z'9fa'), int(Z'8f3'), int(Z'bf9'), int(Z'af0'),         &
                    int(Z'650'), int(Z'759'), int(Z'453'), int(Z'55a'), int(Z'256'), int(Z'35f'), int(Z'55' ), int(Z'15c'),         &
                    int(Z'e5c'), int(Z'f55'), int(Z'c5f'), int(Z'd56'), int(Z'a5a'), int(Z'b53'), int(Z'859'), int(Z'950'),         &
                    int(Z'7c0'), int(Z'6c9'), int(Z'5c3'), int(Z'4ca'), int(Z'3c6'), int(Z'2cf'), int(Z'1c5'), int(Z'cc' ),         &
                    int(Z'fcc'), int(Z'ec5'), int(Z'dcf'), int(Z'cc6'), int(Z'bca'), int(Z'ac3'), int(Z'9c9'), int(Z'8c0'),         &
                    int(Z'8c0'), int(Z'9c9'), int(Z'ac3'), int(Z'bca'), int(Z'cc6'), int(Z'dcf'), int(Z'ec5'), int(Z'fcc'),         &
                    int(Z'cc' ), int(Z'1c5'), int(Z'2cf'), int(Z'3c6'), int(Z'4ca'), int(Z'5c3'), int(Z'6c9'), int(Z'7c0'),         &
                    int(Z'950'), int(Z'859'), int(Z'b53'), int(Z'a5a'), int(Z'd56'), int(Z'c5f'), int(Z'f55'), int(Z'e5c'),         &
                    int(Z'15c'), int(Z'55' ), int(Z'35f'), int(Z'256'), int(Z'55a'), int(Z'453'), int(Z'759'), int(Z'650'),         &
                    int(Z'af0'), int(Z'bf9'), int(Z'8f3'), int(Z'9fa'), int(Z'ef6'), int(Z'fff'), int(Z'cf5'), int(Z'dfc'),         &
                    int(Z'2fc'), int(Z'3f5'), int(Z'ff' ), int(Z'1f6'), int(Z'6fa'), int(Z'7f3'), int(Z'4f9'), int(Z'5f0'),         &
                    int(Z'b60'), int(Z'a69'), int(Z'963'), int(Z'86a'), int(Z'f66'), int(Z'e6f'), int(Z'd65'), int(Z'c6c'),         &
                    int(Z'36c'), int(Z'265'), int(Z'16f'), int(Z'66' ), int(Z'76a'), int(Z'663'), int(Z'569'), int(Z'460'),         &
                    int(Z'ca0'), int(Z'da9'), int(Z'ea3'), int(Z'faa'), int(Z'8a6'), int(Z'9af'), int(Z'aa5'), int(Z'bac'),         &
                    int(Z'4ac'), int(Z'5a5'), int(Z'6af'), int(Z'7a6'), int(Z'aa' ), int(Z'1a3'), int(Z'2a9'), int(Z'3a0'),         &
                    int(Z'd30'), int(Z'c39'), int(Z'f33'), int(Z'e3a'), int(Z'936'), int(Z'83f'), int(Z'b35'), int(Z'a3c'),         &
                    int(Z'53c'), int(Z'435'), int(Z'73f'), int(Z'636'), int(Z'13a'), int(Z'33' ), int(Z'339'), int(Z'230'),         &
                    int(Z'e90'), int(Z'f99'), int(Z'c93'), int(Z'd9a'), int(Z'a96'), int(Z'b9f'), int(Z'895'), int(Z'99c'),         &
                    int(Z'69c'), int(Z'795'), int(Z'49f'), int(Z'596'), int(Z'29a'), int(Z'393'), int(Z'99' ), int(Z'190'),         &
                    int(Z'f00'), int(Z'e09'), int(Z'd03'), int(Z'c0a'), int(Z'b06'), int(Z'a0f'), int(Z'905'), int(Z'80c'),         &
                    int(Z'70c'), int(Z'605'), int(Z'50f'), int(Z'406'), int(Z'30a'), int(Z'203'), int(Z'109'), int(Z'0'  )  /), kind=int32 )

! 
!         integer(kind=int32),dimension(0:255),parameter          ::                          &
!                 EDGETABLE = int( (/                                                         &
!                     Z'0'  , Z'109', Z'203', Z'30a', Z'406', Z'50f', Z'605', Z'70c',         &
!                     Z'80c', Z'905', Z'a0f', Z'b06', Z'c0a', Z'd03', Z'e09', Z'f00',         &
!                     Z'190', Z'99' , Z'393', Z'29a', Z'596', Z'49f', Z'795', Z'69c',         &
!                     Z'99c', Z'895', Z'b9f', Z'a96', Z'd9a', Z'c93', Z'f99', Z'e90',         &
!                     Z'230', Z'339', Z'33' , Z'13a', Z'636', Z'73f', Z'435', Z'53c',         &
!                     Z'a3c', Z'b35', Z'83f', Z'936', Z'e3a', Z'f33', Z'c39', Z'd30',         &
!                     Z'3a0', Z'2a9', Z'1a3', Z'aa' , Z'7a6', Z'6af', Z'5a5', Z'4ac',         &
!                     Z'bac', Z'aa5', Z'9af', Z'8a6', Z'faa', Z'ea3', Z'da9', Z'ca0',         &
!                     Z'460', Z'569', Z'663', Z'76a', Z'66' , Z'16f', Z'265', Z'36c',         &
!                     Z'c6c', Z'd65', Z'e6f', Z'f66', Z'86a', Z'963', Z'a69', Z'b60',         &
!                     Z'5f0', Z'4f9', Z'7f3', Z'6fa', Z'1f6', Z'ff' , Z'3f5', Z'2fc',         &
!                     Z'dfc', Z'cf5', Z'fff', Z'ef6', Z'9fa', Z'8f3', Z'bf9', Z'af0',         &
!                     Z'650', Z'759', Z'453', Z'55a', Z'256', Z'35f', Z'55' , Z'15c',         &
!                     Z'e5c', Z'f55', Z'c5f', Z'd56', Z'a5a', Z'b53', Z'859', Z'950',         &
!                     Z'7c0', Z'6c9', Z'5c3', Z'4ca', Z'3c6', Z'2cf', Z'1c5', Z'cc' ,         &
!                     Z'fcc', Z'ec5', Z'dcf', Z'cc6', Z'bca', Z'ac3', Z'9c9', Z'8c0',         &
!                     Z'8c0', Z'9c9', Z'ac3', Z'bca', Z'cc6', Z'dcf', Z'ec5', Z'fcc',         &
!                     Z'cc' , Z'1c5', Z'2cf', Z'3c6', Z'4ca', Z'5c3', Z'6c9', Z'7c0',         &
!                     Z'950', Z'859', Z'b53', Z'a5a', Z'd56', Z'c5f', Z'f55', Z'e5c',         &
!                     Z'15c', Z'55' , Z'35f', Z'256', Z'55a', Z'453', Z'759', Z'650',         &
!                     Z'af0', Z'bf9', Z'8f3', Z'9fa', Z'ef6', Z'fff', Z'cf5', Z'dfc',         &
!                     Z'2fc', Z'3f5', Z'ff' , Z'1f6', Z'6fa', Z'7f3', Z'4f9', Z'5f0',         &
!                     Z'b60', Z'a69', Z'963', Z'86a', Z'f66', Z'e6f', Z'd65', Z'c6c',         &
!                     Z'36c', Z'265', Z'16f', Z'66' , Z'76a', Z'663', Z'569', Z'460',         &
!                     Z'ca0', Z'da9', Z'ea3', Z'faa', Z'8a6', Z'9af', Z'aa5', Z'bac',         &
!                     Z'4ac', Z'5a5', Z'6af', Z'7a6', Z'aa' , Z'1a3', Z'2a9', Z'3a0',         &
!                     Z'd30', Z'c39', Z'f33', Z'e3a', Z'936', Z'83f', Z'b35', Z'a3c',         &
!                     Z'53c', Z'435', Z'73f', Z'636', Z'13a', Z'33' , Z'339', Z'230',         &
!                     Z'e90', Z'f99', Z'c93', Z'd9a', Z'a96', Z'b9f', Z'895', Z'99c',         &
!                     Z'69c', Z'795', Z'49f', Z'596', Z'29a', Z'393', Z'99' , Z'190',         &
!                     Z'f00', Z'e09', Z'd03', Z'c0a', Z'b06', Z'a0f', Z'905', Z'80c',         &
!                     Z'70c', Z'605', Z'50f', Z'406', Z'30a', Z'203', Z'109', Z'0'    /), kind=int32 )

            integer,dimension(16,0:255),parameter         ::                        &
                TRITABLE = reshape( (/                                              &
                    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, &
                    0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    &
                    0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    &
                    1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   &
                    0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1,        &
                    3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   &
                    0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,     &
                    1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1,       &
                    3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    &
                    0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1,      &
                    3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1,       &
                    9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    &
                    4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    &
                    4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1,          &
                    1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1,         &
                    9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1,         &
                    2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1,            &
                    8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1,        &
                    9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1,         &
                    4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1,          &
                    3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1,       &
                    1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1,         &
                    4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1,         &
                    4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1,      &
                    9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    &
                    9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1,          &
                    1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1,         &
                    5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1,         &
                    2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1,            &
                    9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1,        &
                    0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1,         &
                    2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1,            &
                    10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1,       &
                    4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1,          &
                    5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1,         &
                    5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1,       &
                    9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1,          &
                    0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1,          &
                    1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1,         &
                    10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1,            &
                    8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1,            &
                    2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1,         &
                    7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1,         &
                    9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1,            &
                    2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1,            &
                    11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1,        &
                    9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1,          &
                    5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1,            &
                    11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1,            &
                    11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    &
                    10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   &
                    0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,         &
                    1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1,          &
                    9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1,          &
                    5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1,             &
                    2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,     &
                    11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1,       &
                    0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1,        &
                    5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1,          &
                    6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1,         &
                    0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1,          &
                    3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1,            &
                    6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1,        &
                    5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1,         &
                    1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1,         &
                    10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1,            &
                    6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1,          &
                    1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1,             &
                    8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1,             &
                    7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1,                &
                    3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1,        &
                    5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1,           &
                    0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1,           &
                    9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1,            &
                    8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1,           &
                    5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1,           &
                    0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1,               &
                    6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1,           &
                    10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,     &
                    4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1,        &
                    10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1,        &
                    8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1,            &
                    1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1,          &
                    3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1,             &
                    0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1,          &
                    10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1,       &
                    0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1,          &
                    3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1,           &
                    6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1,             &
                    9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1,            &
                    8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1,              &
                    3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1,         &
                    6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1,       &
                    0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1,          &
                    10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1,           &
                    10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1,        &
                    1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1,             &
                    2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1,                &
                    7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1,          &
                    7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1,          &
                    2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1,             &
                    1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1,             &
                    11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1,          &
                    8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1,               &
                    0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1,           &
                    7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   &
                    7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   &
                    3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,         &
                    10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,     &
                    1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,        &
                    2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1,        &
                    6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1,         &
                    7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1,          &
                    2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1,          &
                    1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1,             &
                    10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1,        &
                    10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1,           &
                    0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1,          &
                    7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1,       &
                    6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1,         &
                    8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1,         &
                    9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1,            &
                    6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1,        &
                    1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1,          &
                    4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1,          &
                    10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1,             &
                    8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1,          &
                    0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1,             &
                    1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1,          &
                    8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1,            &
                    10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1,        &
                    4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1,              &
                    10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,     &
                    4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1,         &
                    5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1,         &
                    11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1,            &
                    9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1,        &
                    6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1,           &
                    7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1,          &
                    3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1,              &
                    7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1,          &
                    9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1,             &
                    3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1,             &
                    6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1,                &
                    9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1,            &
                    1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1,               &
                    4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1,           &
                    7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1,         &
                    6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1,        &
                    3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1,            &
                    0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1,          &
                    6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1,         &
                    1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1,         &
                    0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1,             &
                    11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1,             &
                    6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1,          &
                    5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1,             &
                    9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1,          &
                    1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1,                &
                    1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1,               &
                    10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1,           &
                    0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   &
                    11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    &
                    11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1,       &
                    5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1,       &
                    10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1,          &
                    11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1,        &
                    0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1,            &
                    9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1,            &
                    7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1,               &
                    2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1,         &
                    8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1,            &
                    9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1,           &
                    9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1,               &
                    1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1,          &
                    9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1,          &
                    9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1,       &
                    5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1,         &
                    0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1,         &
                    10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1,            &
                    2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1,            &
                    0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1,           &
                    0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1,              &
                    9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1,            &
                    5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1,         &
                    3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1,              &
                    5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1,            &
                    8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1,          &
                    0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1,             &
                    9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    &
                    4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1,      &
                    0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1,          &
                    1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1,         &
                    3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1,            &
                    4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1,          &
                    9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1,             &
                    11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1,        &
                    11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1,           &
                    2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1,            &
                    9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1,              &
                    3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1,           &
                    1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1,          &
                    4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1,             &
                    4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    &
                    9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    &
                    3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1,       &
                    0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1,      &
                    3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    &
                    1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1,       &
                    3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1,           &
                    0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,     &
                    3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   &
                    2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1,        &
                    9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,      &
                    2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1,           &
                    1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   &
                    1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,       &
                    0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    &
                    0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,    &
                    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1  &
                                /) , (/16,256/) )

    !---
    
        interface   gridCell_ctor
            module procedure    gridCell_ctor0
            module procedure    gridCell_ctor1
        end interface
                                
        
        interface   Polygonize
            module procedure    Polygonize0
            module procedure    Polygonize1
            module procedure    Polygonize1a
            ! module procedure    PolygonizeCube
            module procedure    AutoPolygonizeCube
        end interface
                                
        
        interface   getNTriang
            module procedure   getNTriang0
        end interface
                           
                                
                                

    contains
!---^^^^^^^^


        pure function gridCell_ctor0( dat,ix,iy,iz ) result(this)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*      given data find the gridcell origin ix,iy,iz
            real(kind=real64),dimension(0:,0:,0:),intent(in)        ::      dat
            integer,intent(in)                                      ::      ix,iy,iz
            type(gridcell)                                          ::      this
            
            this%p(1:3,0) = real( (/ ix  ,iy  ,iz   /) ,kind=real64 ) + 0.5d0
            this%p(1:3,1) = real( (/ ix+1,iy  ,iz   /) ,kind=real64 ) + 0.5d0
            this%p(1:3,2) = real( (/ ix+1,iy+1,iz   /) ,kind=real64 ) + 0.5d0
            this%p(1:3,3) = real( (/ ix  ,iy+1,iz   /) ,kind=real64 ) + 0.5d0
            this%p(1:3,4) = real( (/ ix  ,iy  ,iz+1 /) ,kind=real64 ) + 0.5d0
            this%p(1:3,5) = real( (/ ix+1,iy  ,iz+1 /) ,kind=real64 ) + 0.5d0
            this%p(1:3,6) = real( (/ ix+1,iy+1,iz+1 /) ,kind=real64 ) + 0.5d0
            this%p(1:3,7) = real( (/ ix  ,iy+1,iz+1 /) ,kind=real64 ) + 0.5d0
            this%val(0:7) =  (/ dat(ix  ,iy  ,iz  ),dat(ix+1,iy  ,iz  ),dat(ix+1,iy+1,iz  ),dat(ix  ,iy+1,iz  ),         &
                                dat(ix  ,iy  ,iz+1),dat(ix+1,iy  ,iz+1),dat(ix+1,iy+1,iz+1),dat(ix  ,iy+1,iz+1)  /)
                             
            return           
        end function gridCell_ctor0    
                             

        pure function gridCell_ctor1( v ) result(this)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*      given data find the gridcell  
            real(kind=real64),dimension(0:7),intent(in)             ::      v
            type(gridcell)                                          ::      this
            
            this%p(1:3,0) = (/ 0.0d0,0.0d0,0.0d0 /)
            this%p(1:3,1) = (/ 1.0d0,0.0d0,0.0d0 /)
            this%p(1:3,2) = (/ 1.0d0,1.0d0,0.0d0 /)
            this%p(1:3,3) = (/ 0.0d0,1.0d0,0.0d0 /)
            this%p(1:3,4) = (/ 0.0d0,0.0d0,1.0d0 /)
            this%p(1:3,5) = (/ 1.0d0,0.0d0,1.0d0 /)
            this%p(1:3,6) = (/ 1.0d0,1.0d0,1.0d0 /)
            this%p(1:3,7) = (/ 0.0d0,1.0d0,1.0d0 /)
            this%val(0:7) =  v(0:7)
                            
                             
            return           
        end function gridCell_ctor1    
                             
    !---
    
            
            
            
    !---        
                             
        pure subroutine Polygonize0( grid,isolevel, triangles, nTriang )
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*
    !*  Given a grid cell and an isolevel, calculate the triangular
    !*  facets required to represent the isosurface through the cell.
    !*  Return the number of triangular facets, the array "triangles"
    !*  will be loaded up with the vertices at most 5 triangular facets.
    !*  nTriang = 0 will be returned if the grid cell is either totally above
    !*  of totally below the isolevel.
    !*
            type(gridcell),intent(in)                   ::      grid                !   structured data input describing vertices of cube
            real(kind=real64),intent(in)                ::      isolevel            !   level at which to draw surface
            type(tri),dimension(:),intent(inout)        ::      triangles           !   structured data output describing triangles
            integer,intent(inout)                         ::      nTriang



            integer                                 ::      ii,cubeindex
            real(kind=real64),dimension(3,0:11)     ::      vertlist

       !
       ! Determine the index into the edge table which
       ! tells us which vertices are inside of the surface
       !
            cubeindex = 0;
            if (grid%val(0) < isolevel) cubeindex = cubeindex + 1;
            if (grid%val(1) < isolevel) cubeindex = cubeindex + 2;
            if (grid%val(2) < isolevel) cubeindex = cubeindex + 4;
            if (grid%val(3) < isolevel) cubeindex = cubeindex + 8;
            if (grid%val(4) < isolevel) cubeindex = cubeindex + 16;
            if (grid%val(5) < isolevel) cubeindex = cubeindex + 32;
            if (grid%val(6) < isolevel) cubeindex = cubeindex + 64;
            if (grid%val(7) < isolevel) cubeindex = cubeindex + 128;

       ! Cube is entirely in/out of the surface?
            if (EDGETABLE(cubeindex) == 0) return


       ! Find the vertices where the surface intersects the cube
            if (btest(EDGETABLE(cubeindex),0)) &
               vertlist(1:3,0) = VertexInterp(isolevel,grid%p(1:3,0),grid%p(1:3,1),grid%val(0),grid%val(1))
            if (btest(EDGETABLE(cubeindex),1))  &
               vertlist(1:3,1) = VertexInterp(isolevel,grid%p(1:3,1),grid%p(1:3,2),grid%val(1),grid%val(2))
            if (btest(EDGETABLE(cubeindex),2))  &
               vertlist(1:3,2) = VertexInterp(isolevel,grid%p(1:3,2),grid%p(1:3,3),grid%val(2),grid%val(3))
            if (btest(EDGETABLE(cubeindex),3))  &
               vertlist(1:3,3) = VertexInterp(isolevel,grid%p(1:3,3),grid%p(1:3,0),grid%val(3),grid%val(0))
            if (btest(EDGETABLE(cubeindex),4))  &
               vertlist(1:3,4) = VertexInterp(isolevel,grid%p(1:3,4),grid%p(1:3,5),grid%val(4),grid%val(5))
            if (btest(EDGETABLE(cubeindex),5))  &
               vertlist(1:3,5) = VertexInterp(isolevel,grid%p(1:3,5),grid%p(1:3,6),grid%val(5),grid%val(6))
            if (btest(EDGETABLE(cubeindex),6))  &
               vertlist(1:3,6) = VertexInterp(isolevel,grid%p(1:3,6),grid%p(1:3,7),grid%val(6),grid%val(7))
            if (btest(EDGETABLE(cubeindex),7))  &
               vertlist(1:3,7) = VertexInterp(isolevel,grid%p(1:3,7),grid%p(1:3,4),grid%val(7),grid%val(4))
            if (btest(EDGETABLE(cubeindex),8))  &
               vertlist(1:3,8) = VertexInterp(isolevel,grid%p(1:3,0),grid%p(1:3,4),grid%val(0),grid%val(4))
            if (btest(EDGETABLE(cubeindex),9)) &
               vertlist(1:3,9) = VertexInterp(isolevel,grid%p(1:3,1),grid%p(1:3,5),grid%val(1),grid%val(5))
            if (btest(EDGETABLE(cubeindex),10)) &
               vertlist(1:3,10) = VertexInterp(isolevel,grid%p(1:3,2),grid%p(1:3,6),grid%val(2),grid%val(6))
            if (btest(EDGETABLE(cubeindex),11)) &
               vertlist(1:3,11) = VertexInterp(isolevel,grid%p(1:3,3),grid%p(1:3,7),grid%val(3),grid%val(7))

            ! Create the triangle
            ii = 1 ; 
            do
                if (TRITABLE(ii,cubeindex)==-1) exit
                ntriang = ntriang + 1;
                triangles(ntriang)%p(1:3,1) = vertlist(1:3 ,TRITABLE(ii  ,cubeindex) )
                triangles(ntriang)%p(1:3,2) = vertlist(1:3 ,TRITABLE(ii+1,cubeindex) )
                triangles(ntriang)%p(1:3,3) = vertlist(1:3 ,TRITABLE(ii+2,cubeindex) )
                ii = ii + 3
            end do

            return
        end subroutine Polygonize0
        
            
        pure subroutine Polygonize1( grid,isolevel, triangles, nTriang )
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*
    !*  Given a grid cell and an isolevel, calculate the triangular
    !*  facets required to represent the isosurface through the cell.
    !*  Return the number of triangular facets, the array "triangles"
    !*  will be loaded up with the vertices at most 5 triangular facets.
    !*  nTriang = 0 will be returned if the grid cell is either totally above
    !*  of totally below the isolevel.
    !*
            type(gridcell),intent(in)                   ::      grid                !   structured data input describing vertices of cube
            real(kind=real64),intent(in)                ::      isolevel            !   level at which to draw surface
            real(kind=real64),dimension(:,:,:),intent(inout)        ::      triangles           !   structured data output describing triangles
            integer,intent(inout)                         ::      nTriang



            integer                                 ::      ii,cubeindex
            real(kind=real64),dimension(3,0:11)     ::      vertlist

       !
       ! Determine the index into the edge table which
       ! tells us which vertices are inside of the surface
       !
            cubeindex = 0;
            if (grid%val(0) < isolevel) cubeindex = cubeindex + 1;
            if (grid%val(1) < isolevel) cubeindex = cubeindex + 2;
            if (grid%val(2) < isolevel) cubeindex = cubeindex + 4;
            if (grid%val(3) < isolevel) cubeindex = cubeindex + 8;
            if (grid%val(4) < isolevel) cubeindex = cubeindex + 16;
            if (grid%val(5) < isolevel) cubeindex = cubeindex + 32;
            if (grid%val(6) < isolevel) cubeindex = cubeindex + 64;
            if (grid%val(7) < isolevel) cubeindex = cubeindex + 128;

       ! Cube is entirely in/out of the surface?
            if (EDGETABLE(cubeindex) == 0) return


       ! Find the vertices where the surface intersects the cube
            if (btest(EDGETABLE(cubeindex),0)) &
               vertlist(1:3,0) = VertexInterp(isolevel,grid%p(1:3,0),grid%p(1:3,1),grid%val(0),grid%val(1))
            if (btest(EDGETABLE(cubeindex),1))  &
               vertlist(1:3,1) = VertexInterp(isolevel,grid%p(1:3,1),grid%p(1:3,2),grid%val(1),grid%val(2))
            if (btest(EDGETABLE(cubeindex),2))  &
               vertlist(1:3,2) = VertexInterp(isolevel,grid%p(1:3,2),grid%p(1:3,3),grid%val(2),grid%val(3))
            if (btest(EDGETABLE(cubeindex),3))  &
               vertlist(1:3,3) = VertexInterp(isolevel,grid%p(1:3,3),grid%p(1:3,0),grid%val(3),grid%val(0))
            if (btest(EDGETABLE(cubeindex),4))  &
               vertlist(1:3,4) = VertexInterp(isolevel,grid%p(1:3,4),grid%p(1:3,5),grid%val(4),grid%val(5))
            if (btest(EDGETABLE(cubeindex),5))  &
               vertlist(1:3,5) = VertexInterp(isolevel,grid%p(1:3,5),grid%p(1:3,6),grid%val(5),grid%val(6))
            if (btest(EDGETABLE(cubeindex),6))  &
               vertlist(1:3,6) = VertexInterp(isolevel,grid%p(1:3,6),grid%p(1:3,7),grid%val(6),grid%val(7))
            if (btest(EDGETABLE(cubeindex),7))  &
               vertlist(1:3,7) = VertexInterp(isolevel,grid%p(1:3,7),grid%p(1:3,4),grid%val(7),grid%val(4))
            if (btest(EDGETABLE(cubeindex),8))  &
               vertlist(1:3,8) = VertexInterp(isolevel,grid%p(1:3,0),grid%p(1:3,4),grid%val(0),grid%val(4))
            if (btest(EDGETABLE(cubeindex),9)) &
               vertlist(1:3,9) = VertexInterp(isolevel,grid%p(1:3,1),grid%p(1:3,5),grid%val(1),grid%val(5))
            if (btest(EDGETABLE(cubeindex),10)) &
               vertlist(1:3,10) = VertexInterp(isolevel,grid%p(1:3,2),grid%p(1:3,6),grid%val(2),grid%val(6))
            if (btest(EDGETABLE(cubeindex),11)) &
               vertlist(1:3,11) = VertexInterp(isolevel,grid%p(1:3,3),grid%p(1:3,7),grid%val(3),grid%val(7))

            ! Create the triangle
            ii = 1 ; 
            do
                if (TRITABLE(ii,cubeindex)==-1) exit
                ntriang = ntriang + 1;
                triangles(1:3,1,ntriang) = vertlist(1:3 ,TRITABLE(ii  ,cubeindex) )
                triangles(1:3,2,ntriang) = vertlist(1:3 ,TRITABLE(ii+1,cubeindex) )
                triangles(1:3,3,ntriang) = vertlist(1:3 ,TRITABLE(ii+2,cubeindex) )
                ii = ii + 3
            end do

            return
        end subroutine Polygonize1

            
            
        pure subroutine Polygonize1a( val,isolevel, triangles, nTriang )
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*
    !*  Given a grid cell and an isolevel, calculate the triangular
    !*  facets required to represent the isosurface through the cell.
    !*  Return the number of triangular facets, the array "triangles"
    !*  will be loaded up with the vertices at most 5 triangular facets.
    !*  nTriang = 0 will be returned if the grid cell is either totally above
    !*  of totally below the isolevel.
    !*
            real(kind=real64),dimension(0:7),intent(in)             ::      val                !   structured data input describing vertices of cube
            real(kind=real64),intent(in)                            ::      isolevel            !   level at which to draw surface
            real(kind=real64),dimension(:,:,:),intent(out)          ::      triangles           !   structured data output describing triangles
            integer,intent(out)                                     ::      nTriang



            integer                                 ::      ii,cubeindex
            real(kind=real64),dimension(3,0:11)     ::      vertlist

       !
       ! Determine the index into the edge table which
       ! tells us which vertices are inside of the surface
       !
            cubeindex = 0;
            if (val(0) < isolevel) cubeindex = cubeindex + 1;
            if (val(1) < isolevel) cubeindex = cubeindex + 2;
            if (val(2) < isolevel) cubeindex = cubeindex + 4;
            if (val(3) < isolevel) cubeindex = cubeindex + 8;
            if (val(4) < isolevel) cubeindex = cubeindex + 16;
            if (val(5) < isolevel) cubeindex = cubeindex + 32;
            if (val(6) < isolevel) cubeindex = cubeindex + 64;
            if (val(7) < isolevel) cubeindex = cubeindex + 128;

       ! Cube is entirely in/out of the surface?
            ntriang = 0
            if (EDGETABLE(cubeindex) == 0) return


       ! Find the vertices where the surface intersects the cube
            if (btest(EDGETABLE(cubeindex),0)) &
               vertlist(1:3,0) = VertexInterp(isolevel,(/0d0,0d0,0d0/),(/1d0,0d0,0d0/),val(0),val(1))
            if (btest(EDGETABLE(cubeindex),1))  &
               vertlist(1:3,1) = VertexInterp(isolevel,(/1d0,0d0,0d0/),(/1d0,1d0,0d0/),val(1),val(2))
            if (btest(EDGETABLE(cubeindex),2))  &
               vertlist(1:3,2) = VertexInterp(isolevel,(/1d0,1d0,0d0/),(/0d0,1d0,0d0/),val(2),val(3))
            if (btest(EDGETABLE(cubeindex),3))  &
               vertlist(1:3,3) = VertexInterp(isolevel,(/0d0,1d0,0d0/),(/0d0,0d0,0d0/),val(3),val(0))
            if (btest(EDGETABLE(cubeindex),4))  &
               vertlist(1:3,4) = VertexInterp(isolevel,(/0d0,0d0,1d0/),(/1d0,0d0,1d0/),val(4),val(5))
            if (btest(EDGETABLE(cubeindex),5))  &
               vertlist(1:3,5) = VertexInterp(isolevel,(/1d0,0d0,1d0/),(/1d0,1d0,1d0/),val(5),val(6))
            if (btest(EDGETABLE(cubeindex),6))  &
               vertlist(1:3,6) = VertexInterp(isolevel,(/1d0,1d0,1d0/),(/0d0,1d0,1d0/),val(6),val(7))
            if (btest(EDGETABLE(cubeindex),7))  &
               vertlist(1:3,7) = VertexInterp(isolevel,(/0d0,1d0,1d0/),(/0d0,0d0,1d0/),val(7),val(4))
            if (btest(EDGETABLE(cubeindex),8))  &
               vertlist(1:3,8) = VertexInterp(isolevel,(/0d0,0d0,0d0/),(/0d0,0d0,1d0/),val(0),val(4))
            if (btest(EDGETABLE(cubeindex),9)) &
               vertlist(1:3,9) = VertexInterp(isolevel,(/1d0,0d0,0d0/),(/1d0,0d0,1d0/),val(1),val(5))
            if (btest(EDGETABLE(cubeindex),10)) &
               vertlist(1:3,10) = VertexInterp(isolevel,(/1d0,1d0,0d0/),(/1d0,1d0,1d0/),val(2),val(6))
            if (btest(EDGETABLE(cubeindex),11)) &
               vertlist(1:3,11) = VertexInterp(isolevel,(/0d0,1d0,0d0/),(/0d0,1d0,1d0/),val(3),val(7))

            ! Create the triangle
            ii = 1 
            do
                if (TRITABLE(ii,cubeindex)==-1) exit
                ntriang = ntriang + 1;
                triangles(1:3,1,ntriang) = vertlist(1:3 ,TRITABLE(ii  ,cubeindex) )
                triangles(1:3,2,ntriang) = vertlist(1:3 ,TRITABLE(ii+1,cubeindex) )
                triangles(1:3,3,ntriang) = vertlist(1:3 ,TRITABLE(ii+2,cubeindex) )
                ii = ii + 3
            end do

            return
        end subroutine Polygonize1a

            

        pure function getNTriang0( grid,isolevel ) result ( nTriang )
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*
    !*  Given a grid cell and an isolevel, calculate the number of triangular
    !*  facets required to represent the isosurface through the cell.
    !*  Return the number of triangular facets, the array "triangles"
    !*  will be loaded up with the vertices at most 5 triangular facets.
    !*  0 will be returned if the grid cell is either totally above
    !*  of totally below the isolevel.
    !*
            type(gridcell),intent(in)                   ::      grid                !   structured data input describing vertices of cube
            real(kind=real64),intent(in)                ::      isolevel            !   level at which to draw surface                   
            integer                                     ::      nTriang

            integer                     ::      ii,cubeindex

       !
       ! Determine the index into the edge table which
       ! tells us which vertices are inside of the surface
       !
            cubeindex = 0 
            if (grid%val(0) < isolevel) cubeindex = cubeindex + 1 
            if (grid%val(1) < isolevel) cubeindex = cubeindex + 2 
            if (grid%val(2) < isolevel) cubeindex = cubeindex + 4 
            if (grid%val(3) < isolevel) cubeindex = cubeindex + 8 
            if (grid%val(4) < isolevel) cubeindex = cubeindex + 16  
            if (grid%val(5) < isolevel) cubeindex = cubeindex + 32  
            if (grid%val(6) < isolevel) cubeindex = cubeindex + 64  
            if (grid%val(7) < isolevel) cubeindex = cubeindex + 128 

        ! Cube is entirely in/out of the surface
            nTriang = 0
            if (EDGETABLE(cubeindex) == 0) return

        ! Count the triangles
            ii = 1
            do
                if (TRITABLE(ii,cubeindex)==-1) exit
                ntriang = ntriang + 1
                ii = ii + 3
            end do

            return
        end function getNTriang0
        


!------

        recursive subroutine PolygonizeCube(grid,isolevel,triangles,nTriang,split,level )
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*      polygonize the grid cube
    !*      add new triangles to the list accordingly
            type(GridCell),intent(in)                   ::      grid            
            real(kind=real64),intent(in)                ::      isolevel
            real(kind=real64),dimension(:,:,:),intent(inout)        ::      triangles
            integer,intent(inout)                       ::      nTriang
            logical,intent(out)                         ::      split
            integer,intent(in),optional                 ::      level
            
            integer                                 ::      cubeindex
            real(kind=real64),dimension(0:26)       ::      val_interp
            real(kind=real64),dimension(3,0:26)     ::      p_interp
            type(GridCell)                          ::      g
            integer                                 ::      ii,jj,ll
            logical                                 ::      secondsplit
            real(kind=real64),dimension(3,0:11)     ::      vertlist
            
            integer,dimension(0:7,1:8)      ::      corners =       &
                    reshape(    (/  0 ,1 ,4 ,3 ,9 ,10,13,12,        &
                                    1 ,2 ,5 ,4 ,10,11,14,13,        &
                                    3 ,4 ,7 ,6 ,12,13,16,15,        &
                                    4 ,5 ,8 ,7 ,13,14,17,16,        &
                                    9 ,10,13,12,18,19,22,21,        &
                                    10,11,14,13,19,20,23,22,        &
                                    12,13,16,15,21,22,25,24,        &
                                    13,14,17,16,22,23,26,25 /) , (/8,8/) )

            integer,dimension(0:7,0:26)     ::      interp =        &
                    reshape(    (/  8,0,0,0,0,0,0,0,                &       !   layer z = 0
                                    4,4,0,0,0,0,0,0,                &       !
                                    0,8,0,0,0,0,0,0,                &       !
                                    4,0,0,4,0,0,0,0,                &       !
                                    2,2,2,2,0,0,0,0,                &       !
                                    0,4,4,0,0,0,0,0,                &       !
                                    0,0,0,8,0,0,0,0,                &       !
                                    0,0,4,4,0,0,0,0,                &       !
                                    0,0,8,0,0,0,0,0,                &       !
                                    4,0,0,0,4,0,0,0,                &       !   layer z = 0.5
                                    2,2,0,0,2,2,0,0,                &       !   
                                    0,4,0,0,0,4,0,0,                &       ! 
                                    2,0,0,2,2,0,0,2,                &       ! 
                                    1,1,1,1,1,1,1,1,                &       ! 
                                    0,2,2,0,0,2,2,0,                &       ! 
                                    0,0,0,4,0,0,0,4,                &       ! 
                                    0,0,2,2,0,0,2,2,                &       ! 
                                    0,0,4,0,0,0,4,0,                &       ! 
                                    0,0,0,0,8,0,0,0,                &       !   layer z = 1 
                                    0,0,0,0,4,4,0,0,                &       
                                    0,0,0,0,0,8,0,0,                &
                                    0,0,0,0,4,0,0,4,                &
                                    0,0,0,0,2,2,2,2,                &
                                    0,0,0,0,0,4,4,0,                &
                                    0,0,0,0,0,0,0,8,                &
                                    0,0,0,0,0,0,4,4,                &
                                    0,0,0,0,0,0,8,0  /),(/8,27/) )



!           nTriang = 0
            if (all(grid%val < isolevel)) return
            if (all(grid%val > isolevel)) return

            ll = 1 ; if (present(level)) ll = level
            split = .false.
            if (ll < 4) then
                cubeindex = 0
                if (grid%val(0) < isolevel) cubeindex = cubeindex + 1
                if (grid%val(1) < isolevel) cubeindex = cubeindex + 2
                if (grid%val(2) < isolevel) cubeindex = cubeindex + 4
                if (grid%val(3) < isolevel) cubeindex = cubeindex + 8
                if (grid%val(4) < isolevel) cubeindex = cubeindex + 16
                if (grid%val(5) < isolevel) cubeindex = cubeindex + 32
                if (grid%val(6) < isolevel) cubeindex = cubeindex + 64
                if (grid%val(7) < isolevel) cubeindex = cubeindex + 128

                split = ( (iand(cubeindex,15)==5)   .or.(iand(cubeindex,15)==10)  .or.  &
                          (iand(cubeindex,51)==18)  .or.(iand(cubeindex,51)==33)  .or.  &
                          (iand(cubeindex,153)==129).or.(iand(cubeindex,153)==24) .or.  &
                          (iand(cubeindex,102)==66) .or.(iand(cubeindex,102)==36) .or.  &
                          (iand(cubeindex,204)==132).or.(iand(cubeindex,204)==72) .or.  &
                          (iand(cubeindex,240)==80) .or.(iand(cubeindex,240)==160).or.  &
                          (iand(cubeindex,170)==40) .or.(iand(cubeindex,170)==130).or.  &
                          (iand(cubeindex,195)==130).or.(iand(cubeindex,195)==65) .or.  &
                          (iand(cubeindex,85)==65)  .or.(iand(cubeindex,85)==20)  .or.  &
                          (iand(cubeindex,60)==20)  .or.(iand(cubeindex,60)==40)  .or.  &
                          (iand(cubeindex,150)==130).or.(iand(cubeindex,150)==20) .or.  &
                          (iand(cubeindex,105)==65) .or.(iand(cubeindex,105)==40) .or.  &
                          (cubeindex==170)  .or. (cubeindex==60)  .or.                  &
                          (cubeindex==150)  .or. (cubeindex==105) .or.                  &
                          (cubeindex==195)  .or. (cubeindex==85)  ) 

                if (split) then
                    
                    val_interp(:) = 0.0d0
                    p_interp(:,:) = 0.0d0
                    do jj = 0,26
                        do ii = 0,7
                            val_interp(jj)   = val_interp(jj)   + interp(ii,jj)*grid%val(ii)
                            p_interp(1:3,jj) = p_interp(1:3,jj) + interp(ii,jj)*grid%p(1:3,ii)
                        end do
                    end do
                    val_interp(0:26)   = val_interp(0:26)/8
                    p_interp(1:3,0:26) = p_interp(1:3,0:26)/8
                    do jj = 1,8
                        do ii = 0,7
                            g%p(1:3,ii) = p_interp(1:3,corners(ii,jj))
                            g%val(ii)   = val_interp(corners(ii,jj))
                        end do
                        call PolygonizeCube( g,isolevel, triangles(:,:,nTriang+1:), nTriang,secondsplit,ll+1 )
!                        call Polygonize( g,isolevel, triangles, nTriang )
!                        print *,"Lib_MarchingCubes::PolygonizeCube info - split,level = ",split,ll,ii,nTriang
                        
                    end do
                    return
                end if
            else
                split = .true.
            end if
            
       ! Cube is entirely in/out of the surface?
            if (EDGETABLE(cubeindex) == 0) return


       ! Find the vertices where the surface intersects the cube
            if (btest(EDGETABLE(cubeindex),0)) &
               vertlist(1:3,0)  = VertexInterp(isolevel,grid%p(1:3,0),grid%p(1:3,1),grid%val(0),grid%val(1))
            if (btest(EDGETABLE(cubeindex),1))  &
               vertlist(1:3,1)  = VertexInterp(isolevel,grid%p(1:3,1),grid%p(1:3,2),grid%val(1),grid%val(2))
            if (btest(EDGETABLE(cubeindex),2))  &
               vertlist(1:3,2)  = VertexInterp(isolevel,grid%p(1:3,2),grid%p(1:3,3),grid%val(2),grid%val(3))
            if (btest(EDGETABLE(cubeindex),3))  &
               vertlist(1:3,3)  = VertexInterp(isolevel,grid%p(1:3,3),grid%p(1:3,0),grid%val(3),grid%val(0))
            if (btest(EDGETABLE(cubeindex),4))  &
               vertlist(1:3,4)  = VertexInterp(isolevel,grid%p(1:3,4),grid%p(1:3,5),grid%val(4),grid%val(5))
            if (btest(EDGETABLE(cubeindex),5))  &
               vertlist(1:3,5)  = VertexInterp(isolevel,grid%p(1:3,5),grid%p(1:3,6),grid%val(5),grid%val(6))
            if (btest(EDGETABLE(cubeindex),6))  &
               vertlist(1:3,6)  = VertexInterp(isolevel,grid%p(1:3,6),grid%p(1:3,7),grid%val(6),grid%val(7))
            if (btest(EDGETABLE(cubeindex),7))  &
               vertlist(1:3,7)  = VertexInterp(isolevel,grid%p(1:3,7),grid%p(1:3,4),grid%val(7),grid%val(4))
            if (btest(EDGETABLE(cubeindex),8))  &
               vertlist(1:3,8)  = VertexInterp(isolevel,grid%p(1:3,0),grid%p(1:3,4),grid%val(0),grid%val(4))
            if (btest(EDGETABLE(cubeindex),9)) &
               vertlist(1:3,9)  = VertexInterp(isolevel,grid%p(1:3,1),grid%p(1:3,5),grid%val(1),grid%val(5))
            if (btest(EDGETABLE(cubeindex),10)) &
               vertlist(1:3,10) = VertexInterp(isolevel,grid%p(1:3,2),grid%p(1:3,6),grid%val(2),grid%val(6))
            if (btest(EDGETABLE(cubeindex),11)) &
               vertlist(1:3,11) = VertexInterp(isolevel,grid%p(1:3,3),grid%p(1:3,7),grid%val(3),grid%val(7))

            ! Create the triangle
            ii = 1 ; 
            do
                if (TRITABLE(ii,cubeindex)==-1) exit
                ntriang = ntriang + 1;
                triangles(1:3,1,ntriang) = vertlist(1:3 ,TRITABLE(ii  ,cubeindex) )
                triangles(1:3,2,ntriang) = vertlist(1:3 ,TRITABLE(ii+1,cubeindex) )
                triangles(1:3,3,ntriang) = vertlist(1:3 ,TRITABLE(ii+2,cubeindex) )
                ii = ii + 3
            end do

            !call Polygonize( grid,isolevel, triangles(:,:,nTriang+1:), nTriang )
            return
       end subroutine PolygonizeCube




        recursive subroutine AutoPolygonizeCube(grid,isolevel,triangles,nTriang,split,level )
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*      polygonize the grid cube
    !*      add new triangles to the list accordingly
            type(GridCell),intent(in)                   ::      grid            
            real(kind=real64),intent(in)                ::      isolevel
            real(kind=real64),dimension(:,:,:),intent(inout)        ::      triangles
            integer,intent(inout)                       ::      nTriang
            logical,intent(out)                         ::      split
            integer,intent(in),optional                 ::      level
            
            integer                                 ::      cubeindex
            real(kind=real64),dimension(0:26)       ::      val_interp
            real(kind=real64),dimension(3,0:26)     ::      p_interp
            type(GridCell)                          ::      g
            integer                                 ::      ii,jj,ll  
            logical                                 ::      secondsplit
            real(kind=real64),dimension(3,0:11)     ::      vertlist
            
            integer,dimension(0:7,1:8)      ::      corners =       &
                    reshape(    (/  0 ,1 ,4 ,3 ,9 ,10,13,12,        &
                                    1 ,2 ,5 ,4 ,10,11,14,13,        &
                                    3 ,4 ,7 ,6 ,12,13,16,15,        &
                                    4 ,5 ,8 ,7 ,13,14,17,16,        &
                                    9 ,10,13,12,18,19,22,21,        &
                                    10,11,14,13,19,20,23,22,        &
                                    12,13,16,15,21,22,25,24,        &
                                    13,14,17,16,22,23,26,25 /) , (/8,8/) )

            integer,dimension(0:7,0:26)     ::      interp =        &
                    reshape(    (/  8,0,0,0,0,0,0,0,                &       !   layer z = 0
                                    4,4,0,0,0,0,0,0,                &       !
                                    0,8,0,0,0,0,0,0,                &       !
                                    4,0,0,4,0,0,0,0,                &       !
                                    2,2,2,2,0,0,0,0,                &       !
                                    0,4,4,0,0,0,0,0,                &       !
                                    0,0,0,8,0,0,0,0,                &       !
                                    0,0,4,4,0,0,0,0,                &       !
                                    0,0,8,0,0,0,0,0,                &       !
                                    4,0,0,0,4,0,0,0,                &       !   layer z = 0.5
                                    2,2,0,0,2,2,0,0,                &       !   
                                    0,4,0,0,0,4,0,0,                &       ! 
                                    2,0,0,2,2,0,0,2,                &       ! 
                                    1,1,1,1,1,1,1,1,                &       ! 
                                    0,2,2,0,0,2,2,0,                &       ! 
                                    0,0,0,4,0,0,0,4,                &       ! 
                                    0,0,2,2,0,0,2,2,                &       ! 
                                    0,0,4,0,0,0,4,0,                &       ! 
                                    0,0,0,0,8,0,0,0,                &       !   layer z = 1 
                                    0,0,0,0,4,4,0,0,                &       
                                    0,0,0,0,0,8,0,0,                &
                                    0,0,0,0,4,0,0,4,                &
                                    0,0,0,0,2,2,2,2,                &
                                    0,0,0,0,0,4,4,0,                &
                                    0,0,0,0,0,0,0,8,                &
                                    0,0,0,0,0,0,4,4,                &
                                    0,0,0,0,0,0,8,0  /),(/8,27/) )



!           nTriang = 0
            if (all(grid%val < isolevel)) return
            if (all(grid%val > isolevel)) return

            ll = 1 ; if (present(level)) ll = level
            split = .true.
            
                cubeindex = 0
                if (grid%val(0) < isolevel) cubeindex = cubeindex + 1
                if (grid%val(1) < isolevel) cubeindex = cubeindex + 2
                if (grid%val(2) < isolevel) cubeindex = cubeindex + 4
                if (grid%val(3) < isolevel) cubeindex = cubeindex + 8
                if (grid%val(4) < isolevel) cubeindex = cubeindex + 16
                if (grid%val(5) < isolevel) cubeindex = cubeindex + 32
                if (grid%val(6) < isolevel) cubeindex = cubeindex + 64
                if (grid%val(7) < isolevel) cubeindex = cubeindex + 128

!               split = ( (iand(cubeindex,15)==5)   .or.(iand(cubeindex,15)==10)  .or.  &
!                         (iand(cubeindex,51)==18)  .or.(iand(cubeindex,51)==33)  .or.  &
!                         (iand(cubeindex,153)==129).or.(iand(cubeindex,153)==24) .or.  &
!                         (iand(cubeindex,102)==66) .or.(iand(cubeindex,102)==36) .or.  &
!                         (iand(cubeindex,204)==132).or.(iand(cubeindex,204)==72) .or.  &
!                         (iand(cubeindex,240)==80) .or.(iand(cubeindex,240)==160).or.  &
!                         (iand(cubeindex,170)==40) .or.(iand(cubeindex,170)==130).or.  &
!                         (iand(cubeindex,195)==130).or.(iand(cubeindex,195)==65) .or.  &
!                         (iand(cubeindex,85)==65)  .or.(iand(cubeindex,85)==20)  .or.  &
!                         (iand(cubeindex,60)==20)  .or.(iand(cubeindex,60)==40)  .or.  &
!                         (iand(cubeindex,150)==130).or.(iand(cubeindex,150)==20) .or.  &
!                         (iand(cubeindex,105)==65) .or.(iand(cubeindex,105)==40) .or.  &
!                         (cubeindex==170)  .or. (cubeindex==60)  .or.                  &
!                         (cubeindex==150)  .or. (cubeindex==105) .or.                  &
!                         (cubeindex==195)  .or. (cubeindex==85)  ) 
!

            !print *,"Lib_MarchingCubes::AutoPolygonizeCube - info ll,cubeindex,nTriang,size(triangles) ",ll,cubeindex,nTriang,size(triangles)
            if (ll < 3) then          
                val_interp(:) = 0.0d0
                p_interp(:,:) = 0.0d0
                do jj = 0,26
                    do ii = 0,7
                        val_interp(jj)   = val_interp(jj)   + interp(ii,jj)*grid%val(ii)
                        p_interp(1:3,jj) = p_interp(1:3,jj) + interp(ii,jj)*grid%p(1:3,ii)
                    end do
                end do
                val_interp(0:26)   = val_interp(0:26)/8
                p_interp(1:3,0:26) = p_interp(1:3,0:26)/8
                do jj = 1,8
                    do ii = 0,7
                        g%p(1:3,ii) = p_interp(1:3,corners(ii,jj))
                        g%val(ii)   = val_interp(corners(ii,jj))
                    end do
                    call AutoPolygonizeCube( g,isolevel, triangles, nTriang,secondsplit,ll+1 )
!                        call Polygonize( g,isolevel, triangles, nTriang )
!                        print *,"Lib_MarchingCubes::PolygonizeCube info - split,level = ",split,ll,ii,nTriang
                    
                end do
                return
            end if
            
       ! Cube is entirely in/out of the surface?
            if (EDGETABLE(cubeindex) == 0) return


       ! Find the vertices where the surface intersects the cube
            if (btest(EDGETABLE(cubeindex),0)) &
               vertlist(1:3,0)  = VertexInterp(isolevel,grid%p(1:3,0),grid%p(1:3,1),grid%val(0),grid%val(1))
            if (btest(EDGETABLE(cubeindex),1))  &
               vertlist(1:3,1)  = VertexInterp(isolevel,grid%p(1:3,1),grid%p(1:3,2),grid%val(1),grid%val(2))
            if (btest(EDGETABLE(cubeindex),2))  &
               vertlist(1:3,2)  = VertexInterp(isolevel,grid%p(1:3,2),grid%p(1:3,3),grid%val(2),grid%val(3))
            if (btest(EDGETABLE(cubeindex),3))  &
               vertlist(1:3,3)  = VertexInterp(isolevel,grid%p(1:3,3),grid%p(1:3,0),grid%val(3),grid%val(0))
            if (btest(EDGETABLE(cubeindex),4))  &
               vertlist(1:3,4)  = VertexInterp(isolevel,grid%p(1:3,4),grid%p(1:3,5),grid%val(4),grid%val(5))
            if (btest(EDGETABLE(cubeindex),5))  &
               vertlist(1:3,5)  = VertexInterp(isolevel,grid%p(1:3,5),grid%p(1:3,6),grid%val(5),grid%val(6))
            if (btest(EDGETABLE(cubeindex),6))  &
               vertlist(1:3,6)  = VertexInterp(isolevel,grid%p(1:3,6),grid%p(1:3,7),grid%val(6),grid%val(7))
            if (btest(EDGETABLE(cubeindex),7))  &
               vertlist(1:3,7)  = VertexInterp(isolevel,grid%p(1:3,7),grid%p(1:3,4),grid%val(7),grid%val(4))
            if (btest(EDGETABLE(cubeindex),8))  &
               vertlist(1:3,8)  = VertexInterp(isolevel,grid%p(1:3,0),grid%p(1:3,4),grid%val(0),grid%val(4))
            if (btest(EDGETABLE(cubeindex),9)) &
               vertlist(1:3,9)  = VertexInterp(isolevel,grid%p(1:3,1),grid%p(1:3,5),grid%val(1),grid%val(5))
            if (btest(EDGETABLE(cubeindex),10)) &
               vertlist(1:3,10) = VertexInterp(isolevel,grid%p(1:3,2),grid%p(1:3,6),grid%val(2),grid%val(6))
            if (btest(EDGETABLE(cubeindex),11)) &
               vertlist(1:3,11) = VertexInterp(isolevel,grid%p(1:3,3),grid%p(1:3,7),grid%val(3),grid%val(7))

            ! Create the triangle
            ii = 1 ; 
            do
                if (TRITABLE(ii,cubeindex)==-1) exit
                ntriang = ntriang + 1;
                triangles(1:3,1,ntriang) = vertlist(1:3 ,TRITABLE(ii  ,cubeindex) )
                triangles(1:3,2,ntriang) = vertlist(1:3 ,TRITABLE(ii+1,cubeindex) )
                triangles(1:3,3,ntriang) = vertlist(1:3 ,TRITABLE(ii+2,cubeindex) )
                ii = ii + 3
            end do

            !call Polygonize( grid,isolevel, triangles(:,:,nTriang+1:), nTriang )
            return
       end subroutine AutoPolygonizeCube





        pure function VertexInterp(isolevel,p1,p2,valp1,valp2) result(p)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !    Linearly interpolate the position where an isosurface cuts
    !    an edge between two vertices, each with their own scalar value
            real(kind=real64),intent(in)                 ::      isolevel
            real(kind=real64),dimension(3),intent(in)    ::      p1,p2
            real(kind=real64),intent(in)                 ::      valp1,valp2
            real(kind=real64),dimension(3)               ::      p

            real(kind=real64)                ::  mu
            real(kind=real64),parameter      ::  EPS = 1.0d-12

            if (ABS(isolevel-valp1) < EPS) then
                p(1:3) = p1(1:3)
                return
            end if
            if (ABS(isolevel-valp2) < EPS) then
                p(1:3) = p2(1:3)
                return
            end if
            if (ABS(valp2-valp1) < EPS) then
                p(1:3) = (p1(1:3)+p2(1:3))/2
                return
            end if
            mu = (isolevel - valp1) / (valp2 - valp1)
            p(1:3) = p1(1:3) + mu * (p2(1:3) - p1(1:3))

            return
        end function VertexInterp


    end module Lib_MarchingCubes

! 
!     program testLib_MarchingCubes
! !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
!         use Lib_MarchingCubes
!         use iso_fortran_env
!         implicit none
!   
!         real(kind=real64),parameter              ::      PI = 3.1415926535897932384626433832795d0
!   
!         integer                                       ::      N = 20
!         real(kind=real64),dimension(2,3),parameter    ::      bounds = reshape(   &
!                     (/  0.0,1.0 , 0.0,1.0 , 0.0,1.0 /) , (/ 2,3 /) )
!                     
!         real(kind=real64),dimension(:,:,:),allocatable        ::      dat
!         integer                       ::      ix,iy,iz
!         real(kind=real64)             ::      xx,yy,zz,rr,qq,aa
!         real(kind=real64)             ::      delta
!   
!         type(GridCell)                                ::      grid
!         type(Tri),dimension(:),allocatable       ::      triangles
!         type(Tri),dimension(5)                   ::      tri
!         integer                                       ::      nTriang
!         integer                       ::      nn
!         real(kind=real64)             ::      isolevel
!   
!         print *,"enter isolevel "
!         read(*,*) isolevel
!         
!         print *,"enter number of grid divisions "
!         read(*,*) N
!         
!         
!     !---    allocate memory for the voxelised data and the triangles
!         allocate(dat(N,N,N))
!         allocate(triangles(5*N*N*N))
!   
!     !---    fill up voxels with an arbitrary function ( insert load from file here )
!         delta = 1.0d0/N
!         aa = 0.025d0
!         do iz = 1,N
!             do iy = 1,N
!                 do ix = 1,N
!                     xx = (ix*delta - 0.5d0)/aa
!                     yy = (iy*delta - 0.5d0)/aa
!                     zz = (iz*delta - 0.5d0)/aa
!                     rr = sqrt( xx*xx + yy*yy + zz*zz )
!                     qq = ( 4/(81*sqrt(30.0d0)) ) * (rr*rr) * exp( -rr/3 )
!                     if (rr>1.0d-8) then
!                         dat(ix,iy,iz) = 1.0d5*(qq*sqrt(5.0d0/(16*PI))*(xx*xx-yy*yy)/(rr*rr))**2
!                     else
!                         dat(ix,iy,iz) = 0.0
!                     end if
!                 end do
!             end do
!         end do
!   
!         
!     !---    triangulate the surface
!         nn = 0
!         do iz = 1,N-1
!             do iy = 1,N-1
!                 do ix = 1,N-1
!                     xx = real(ix,kind=real64)/N
!                     yy = real(iy,kind=real64)/N
!                     zz = real(iz,kind=real64)/N
!   
!                                   
!                 !---  determine the positions and values at the corners of each voxel
!                     (/0d0,0d0,0d0/) = (/ xx,yy,zz /)
!                     grid%p(1:3,1) = (/ xx+delta,yy,zz /)
!                     grid%p(1:3,2) = (/ xx+delta,yy+delta,zz /)
!                     grid%p(1:3,3) = (/ xx,yy+delta,zz /)
!                     grid%p(1:3,4) = (/ xx,yy,zz+delta /)
!                     grid%p(1:3,5) = (/ xx+delta,yy,zz+delta /)
!                     grid%p(1:3,6) = (/ xx+delta,yy+delta,zz+delta /)
!                     grid%p(1:3,7) = (/ xx,yy+delta,zz+delta /)
!                     grid%val(0:7) = (/ dat(ix,iy,iz),dat(ix+1,iy,iz),dat(ix+1,iy+1,iz),dat(ix,iy+1,iz),         &
!                                        dat(ix,iy,iz+1),dat(ix+1,iy,iz+1),dat(ix+1,iy+1,iz+1),dat(ix,iy+1,iz+1)  /)
!   
!                 !---    add triangles at the isosurface                                     
!                     call Polygonize( grid,isolevel, tri, nTriang )
!                     triangles(nn+1:nn+nTriang) = tri(1:nTriang)
!                     nn = nn + nTriang
!                     
!                 end do
!             end do
!         end do
! 
!       
!     !---    output the result       
!         print *,"number of triangles ",nn
!         open(unit=400,file="marching.cubes.adv",action="write")
!             write(unit=400,fmt='(a)') "# output from marching cubes alg"
!             write(unit=400,fmt='(a)') "# f(x,y,z) = hydrogenic d-orbital"
!             write(unit=400,fmt='(a,10f16.8)') "# isolevel = ",isolevel
!             write(unit=400,fmt='(i6,a)') nn," # number of triangles"
!             write(unit=400,fmt='(a)') "atom position_x position_y position_z"
!             do ix = 1,nn
!                 write(unit=400,fmt='(a,12f12.5)') "tri ",triangles(ix)%p(1:3,1),triangles(ix)%p(1:3,2),triangles(ix)%p(1:3,3) , triangles(ix)%p(3,:)
!             end do
!         close(unit=400)
!   
!         
!     !---    goodbye
!         deallocate(dat)
!         deallocate(triangles)        
!         
!         print *,""
!         print *,"done"
!         print *,""
!   
!     end program testLib_MarchingCubes
!   

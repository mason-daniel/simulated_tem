
    module Lib_AtomSpace
!---^^^^^^^^^^^^^^^^^^^^^ 
!*      A short module defining a derived type containing a definition of the atom space
!*
!*      The atom space defines a transformation on the atoms 
!*          rt = R ( r - delta )/a
!*      to place the atoms into the imaging space
!*      where r = xyzoffset + a_super [xyz] with [xyz] in range 0:1        
!*      It also stores the bounds of the region where the atoms will be placed after periodic copies are made,
!*      in the form of a region
!*          d1 <= n.rt < d2
!*     
!*      We will assume, for simplicity, that the foil is generated by making 8 periodic replicas in the x-y- directions.
!*  
!*      To use the atom space, you need to do it in steps.
!*          1)  this = AtomSpace_ctor(a,xyzoffset,a_super)              uses only the imaging space grid spacing and data from the .xyz file
!*          2)  setR(this,R)                                            if we know the rotation matrix ( even approximately before fine tuning ) then this sets the foil orientation
!*          3)  setThickness(this) or setThickness(this,r)              determines the z extent of the foil after rotation. Use the atom positions if there is an explicit surface
!*          4)  suggestImagingSpace(this,Nx,Ny,Nz)                 return number of imaging space voxels side a to contain the rotated atom set
!*          5)  setDelta(this,Nx,Ny,Nz)                                 find the displacement so that an atom in centre of .xyz file is in centre of imaging space
!*      
!*      This can all be done in one step if required
!*          this = AtomSpace_ctor(a,xyzoffset,a_super,R [,r])

!*      Daniel Mason
!*      (c) UKAEA September 2024
!*
#ifdef MPI
        use mpi_f08
#endif
        use Lib_ImagingSpace
        use iso_fortran_env
        implicit none
        private
 
        public      ::      Lib_AtomSpace_init_MPI

        public      ::      AtomSpace_ctor
        public      ::      report
        public      ::      delete
         
        public      ::      toImagingSpace
        public      ::      suggestImagingSpace
        public      ::      periodicCopies

        public      ::      getxyzoffset
        public      ::      getdelta
        public      ::      geta_super
        public      ::      getR
        public      ::      getL
        public      ::      getn            !   returns the normal to the plane after cell rotation by R
 
        public      ::      setR            !   sets the rotation matrix R , and the normal to the foil n. Does not set the thickness.
        public      ::      setThickness    !   computes the bounds of the atom box in the imaging space
        public      ::      getThickness    !   returns the bounds of the atom box in the imaging space
        public      ::      setDelta        !   computes offset required so after rotation atom in centre of .xyz box is in centre of imaging box

    !    public      ::      scaledDensity   !   converts atoms per cell into a scaled density range 0:1

        integer,private                     ::      rank = 0
        integer,private                     ::      nProcs = 1         
        integer,public                      ::      Lib_AtomSpace_SIGMA_MULT = 2 


        type,public     ::      AtomSpace
            private
            real(kind=real64)                   ::      ia                  !   (inverse) imaging grid side length
            real(kind=real64),dimension(3)      ::      xyzoffset           !   offset of corner of box in the input xyz. Typically zero, but could be -half cell for eg parcas output
            real(kind=real64),dimension(3)      ::      delta               !   displacement required to place atom in centre of xyz file in centre of imaging space
            real(kind=real64),dimension(3,3)    ::      a_super             !   periodic supercell defined in input xyz file, ie before rotation by R. Columns are the three supercell repeat vectors in the .xyz file
            real(kind=real64),dimension(3,3)    ::      R                   !   rotation matrix
            real(kind=real64),dimension(3)      ::      n0                  !   normal vector defining plane of foil, before rotation by R
            real(kind=real64),dimension(3)      ::      n                   !   normal vector defining plane of foil, including rotation. n = R n0 
            real(kind=real64)                   ::      L                   !   thickness of foil. If we are working with planes, (d2-d1) = L cos(theta). But we can also set this for an explicit surface using atom positions.
        end type 


        interface   AtomSpace_ctor
            module procedure        AtomSpace_null
            module procedure        AtomSpace_ctor0
            module procedure        AtomSpace_ctor1
        end interface
        
        interface   report
            module procedure        report0
        end interface
        
        interface   delete
            module procedure        delete0
        end interface
 

        interface   periodicCopies
            module procedure        periodicCopies0
            module procedure        periodicCopies1
        end interface
 

        interface   getL
            module procedure        getL0
        end interface 

        interface   getxyzoffset
            module procedure        getxyzoffset0
        end interface
        
        interface   getdelta
            module procedure        getdelta0
        end interface

        interface   getn
            module procedure        getn0
        end interface

        interface   geta_super
            module procedure        geta_super0
        end interface
 
        interface   getR
            module procedure        getR0
        end interface

        interface   setR
            module procedure        setR0
        end interface
 
        interface   setdelta
            module procedure        setdelta0
        end interface

        interface   getThickness
            module procedure        getThickness0
            module procedure        getThickness1
        end interface

        interface   seta_super
            module procedure        seta_super0
        end interface
 

    contains
!---^^^^^^^^



!******************************************************************************
!
!           standard functions
!
!******************************************************************************

    

        function AtomSpace_null() result(this)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^    
            type(AtomSpace)                     ::      this
            this%ia = 1.0d0
            this%xyzoffset = 0.0d0
            this%delta = 0.0d0
            call seta_super(  this,reshape( (/1.0d0,0.0d0,0.0d0,0.0d0,1.0d0,0.0d0,0.0d0,0.0d0,1.0d0/),(/3,3/) ) )
            call setR( this,reshape( (/1.0d0,0.0d0,0.0d0,0.0d0,1.0d0,0.0d0,0.0d0,0.0d0,1.0d0/),(/3,3/) ) )
            return
        end function AtomSpace_null
        

        function AtomSpace_ctor0(a,xyzoffset,a_super) result(this)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
            type(AtomSpace)                             ::      this
            real(kind=real64),intent(in)                ::      a
            real(kind=real64),dimension(3),intent(in)   ::      xyzoffset
            real(kind=real64),dimension(3,3),intent(in) ::      a_super
            this = AtomSpace_null()
            this%ia = 1/a
            this%xyzoffset = xyzoffset
            call seta_super( this,a_super )
            call setR( this,reshape( (/1.0d0,0.0d0,0.0d0,0.0d0,1.0d0,0.0d0,0.0d0,0.0d0,1.0d0/),(/3,3/) ) )
            
            return
        end function AtomSpace_ctor0


        function AtomSpace_ctor1(a,xyzoffset,a_super,R,x) result(this)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^     
            type(AtomSpace)                                         ::      this
            real(kind=real64),intent(in)                            ::      a
            real(kind=real64),dimension(3),intent(in)               ::      xyzoffset
            real(kind=real64),dimension(3,3),intent(in)             ::      a_super
            real(kind=real64),dimension(3,3),intent(in)             ::      R
            real(kind=real64),dimension(:,:),intent(in),optional    ::      x       !   (3,nAtoms)  atom positoins for accurate deterination of foil thickness
            integer             ::          Nx,Ny,Nz
            this = AtomSpace_ctor0(a,xyzoffset,a_super)
            call setR( this,R ) 
            if (present(x)) then
                call setThickness(this,x) 
            else
                call setThickness(this)
            end if
            call suggestImagingSpace(this,Nx,Ny,Nz) 
            call setDelta(this,Nx,Ny,Nz)
            return
        end function AtomSpace_ctor1


        subroutine delete0(this)
    !---^^^^^^^^^^^^^^^^^^^^^^^^
            type(AtomSpace),intent(inout)       ::      this
            this = AtomSpace_null()
            return
        end subroutine delete0

        
        subroutine report0(this,u,o)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            type(AtomSpace),intent(in)          ::      this
            integer,intent(in),optional         ::      u,o
            integer     ::      uu,oo
            uu = 6 ; if (present(u)) uu = u
            oo = 0 ; if (present(o)) oo = o
            write(unit=uu,fmt='(a,f16.8,a,3f12.8,a)')         repeat(" ",oo)//"AtomSpace [L=",this%L,", n = ",this%n,"]"
            write(unit=uu,fmt='(a,a48,a4,a16)')      repeat(" ",oo+4),"Rotation Matrix R"," ","disp delta"
            write(unit=uu,fmt='(a,3f16.8,a4,f16.8)') repeat(" ",oo+4),this%R(1,:)," ",this%delta(1)
            write(unit=uu,fmt='(a,3f16.8,a4,f16.8)') repeat(" ",oo+4),this%R(2,:)," ",this%delta(2)
            write(unit=uu,fmt='(a,3f16.8,a4,f16.8)') repeat(" ",oo+4),this%R(3,:)," ",this%delta(3)
            
            return
        end subroutine report0




!******************************************************************************
!
!           member functions
!
!******************************************************************************

        pure function toImagingSpace(this,r) result(rt)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*      rt = R ( r - offset )/a
            type(AtomSpace),intent(in)                  ::      this
            real(kind=real64),dimension(3),intent(in)   ::  r
            real(kind=real64),dimension(3)              ::  rt
            rt(1:3) = r(1:3) - this%delta(1:3)
            rt(1:3) = this%R(1:3,1)*rt(1) + this%R(1:3,2)*rt(2) + this%R(1:3,3)*rt(3) 
            rt = rt * this%ia
            return
        end function toImagingSpace

                 
        subroutine suggestImagingSpace(this,Nx,Ny,Nz,theta)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*      suggest a size for the imaging space which covers all the atoms
    !*      optionally add a divergence angle 
            type(AtomSpace),intent(in)                  ::      this
            integer,intent(out)                         ::      Nx,Ny,Nz
            real(kind=real64),intent(in),optional       ::      theta
             
            real(kind=real64),dimension(3,8)           ::      cornert

            integer             ::      ii,ix,iy,iz , dNxy
            real(kind=real64)   ::      minx,maxx,in3 , d1,d2 , tantheta
            real(kind=real64),parameter         ::      TOL = 1.0d-6
 
            integer             ::      angle_loop
 

        !---    find box corners without periodic replicas, and without divergence angle
            ii = 0
            do iz = 0,1
                do iy = 0,1
                    do ix = 0,1
                        ii = ii + 1
                        cornert(:,ii) = this%xyzoffset(:) + this%a_super(:,1)*ix + this%a_super(:,2)*iy + this%a_super(:,3)*iz
                        cornert(:,ii) = toImagingSpace( this,cornert(:,ii) ) 
                    end do
                end do
            end do
 
        !---    this defines the max/min x-y- extents, and so Nx,Ny
            minx = minval( cornert(1,1:8) ) ; maxx = maxval( cornert(1,1:8) ) ; Nx = ceiling( maxx - minx )
            minx = minval( cornert(2,1:8) ) ; maxx = maxval( cornert(2,1:8) ) ; Ny = ceiling( maxx - minx )
 



        !---    Now points on the foil surface are n.rt = d, with d1 = 0 and d2 = n.rt = n0.a_3 / a
        !       points on the edge of the imaging space are at x=0,x=Nx etc
        !       so find the lines of intersection between these planes, and look for min/max z 
        !       conveniently, these points will also be at y=0,y=Ny etc, so I only have 8 points to check.
        !       n_3 z = d - n_1 x - n_2 y
        !       with x = 0,Nx and y = 0,Ny
            minx = huge(1.0) ; maxx = -huge(1.0d0)
            d1 = -TOL
            d2 = ( this%n0(1)*this%a_super(1,3) + this%n0(2)*this%a_super(2,3) + this%n0(3)*this%a_super(3,3) ) * this%ia + TOL
            in3 = 1/this%n(3)
            tantheta = 0 ; if (present(theta)) tantheta = tan(theta)
            dNxy  = 0
            

            do angle_loop = 1,10

                ix = -dNxy   ; iy = -dNxy   ; minx = min( minx, (d1 - this%n(1)*ix - this%n(2)*iy )*in3 ) ; maxx = max( maxx, (d1 - this%n(1)*ix - this%n(2)*iy )*in3 )
                ix = Nx+dNxy ; iy = -dNxy   ; minx = min( minx, (d1 - this%n(1)*ix - this%n(2)*iy )*in3 ) ; maxx = max( maxx, (d1 - this%n(1)*ix - this%n(2)*iy )*in3 )
                ix = -dNxy   ; iy = Ny+dNxy ; minx = min( minx, (d1 - this%n(1)*ix - this%n(2)*iy )*in3 ) ; maxx = max( maxx, (d1 - this%n(1)*ix - this%n(2)*iy )*in3 )
                ix = Nx+dNxy ; iy = Ny+dNxy ; minx = min( minx, (d1 - this%n(1)*ix - this%n(2)*iy )*in3 ) ; maxx = max( maxx, (d1 - this%n(1)*ix - this%n(2)*iy )*in3 )

                ix = -dNxy   ; iy = -dNxy   ; minx = min( minx, (d2 - this%n(1)*ix - this%n(2)*iy )*in3 ) ; maxx = max( maxx, (d2 - this%n(1)*ix - this%n(2)*iy )*in3 )
                ix = Nx+dNxy ; iy = -dNxy   ; minx = min( minx, (d2 - this%n(1)*ix - this%n(2)*iy )*in3 ) ; maxx = max( maxx, (d2 - this%n(1)*ix - this%n(2)*iy )*in3 )
                ix = -dNxy   ; iy = Ny+dNxy ; minx = min( minx, (d2 - this%n(1)*ix - this%n(2)*iy )*in3 ) ; maxx = max( maxx, (d2 - this%n(1)*ix - this%n(2)*iy )*in3 )
                ix = Nx+dNxy ; iy = Ny+dNxy ; minx = min( minx, (d2 - this%n(1)*ix - this%n(2)*iy )*in3 ) ; maxx = max( maxx, (d2 - this%n(1)*ix - this%n(2)*iy )*in3 )

                Nz = ceiling( maxx - minx )  
                ii = ceiling( Nz * tantheta )
                if (ii>dNxy) then                    
                    dNxy = ii
                    if (rank==0) print *,"Lib_AtomSpace::suggestImagingSpace info - padding for dispersion angle to ",Nx+2*dNxy,",",Ny+2*dNxy
                else
                    exit
                end if
                    
            end do
            Nx = Nx + 2*dNxy
            Ny = Ny + 2*dNxy

            return
        end subroutine suggestImagingSpace

!-------        

        subroutine periodicCopies0(this,x,Nx,Ny,nBuf,np,xtp)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*      given an atom at x, and an imaging space dimension (Nx,Ny,Nz)
    !*      return the number of periodic copies np and position of periodic copies xtp(1:3,1:np) needed
    !*      note that it may be necessary to place atoms one or two cells outside this region too.
            type(AtomSpace),intent(in)                  ::      this
            real(kind=real64),dimension(3),intent(in)   ::      x
            integer,intent(in)                          ::      Nx,Ny
            integer,intent(in)                          ::      nBuf                !   may need some points outside imaging space for buffer region
            integer,intent(out)                         ::      np
            real(kind=real64),dimension(:,:),intent(inout)      ::      xtp         !   (3,9) may need up to 9 replicas of input point x. Though 1 is most probable, and 4 is a corner.

            real(kind=real64),dimension(3)      ::      xx
            real(kind=real64),parameter         ::      TOL = 1.0d-6
            integer                 ::      ix,iy
            logical                 ::      ok
            np = 0
            do iy = -1,1
                do ix = -1,1
                    xx = x(:) + this%a_super(:,1)*ix + this%a_super(:,2)*iy  
                    xx = toImagingSpace( this,xx ) 
                    ok = (xx(1)>-nBuf-TOL).and.(xx(1)<NX+nBuf+TOL)
                    ok = ok .and.(xx(2)>-nBuf-TOL).and.(xx(2)<NY+nBuf+TOL)
                    if (ok) then
                        np = np + 1
                        xtp(:,np) = xx(:)
                    end if
                end do
            end do
            return
        end subroutine periodicCopies0
                    
        subroutine periodicCopies1(this,img,x,np,xtp)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*      given an atom at x, and an imaging space dimension (Nx,Ny,Nz)
    !*      return the number of periodic copies np and position of periodic copies xtp(1:3,1:np) needed
    !*      note that it may be necessary to place atoms one or two cells outside this region too.
            type(AtomSpace),intent(in)                  ::      this
            type(ImagingSpace),intent(in)               ::      img
            real(kind=real64),dimension(3),intent(in)   ::      x
            integer,intent(out)                         ::      np
            real(kind=real64),dimension(:,:),intent(inout)  ::      xtp             !   (3,9)
            call periodicCopies0(this,x,getNx(img),getNy(img),getnBuf(img),np,xtp)
            return
        end subroutine periodicCopies1


    !     pure real(kind=real64) function scaledDensity(rho,rho0)
    ! !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    ! !*      given the density per imaging space rho, and the expected average density rho0,
    ! !*      compute a scaled density in the range 0:1, where 
    !         real(kind=real64),intent(in)                ::      rho
    !         real(kind=real64),intent(in)                ::      rho0

    !         real(kind=real64)               ::      xx
    !         if (rho < 0) then       !   not sure how this can possibly happen!?
    !             scaledDensity = 0.0d0
    !         else if (rho > rho0) then
    !             scaledDensity = 1.0d0
    !         else 
    !             xx = rho/rho0
    !             scaledDensity = xx*xx*xx*(10 + xx*(-15+6*xx))
    !         end if

    !         return
    !     end function scaledDensity

!******************************************************************************
!
!           Accessors
!
!******************************************************************************



        
        pure real(kind=real64) function getia0(this) 
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            type(AtomSpace),intent(in)          ::      this
            getia0 = this%ia
            return
        end function getia0

        pure real(kind=real64) function getL0(this) 
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            type(AtomSpace),intent(in)          ::      this
            getL0 = this%L
            return
        end function getL0


        pure function getxyzoffset0(this) result (xyzoffset)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            type(AtomSpace),intent(in)             ::      this
            real(kind=real64),dimension(3)         ::      xyzoffset
            xyzoffset = this%xyzoffset
            return
        end function getxyzoffset0
        
        pure function getdelta0(this) result (delta)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
            type(AtomSpace),intent(in)              ::      this
            real(kind=real64),dimension(3)          ::      delta
            delta = this%delta
            return
        end function getdelta0
        
        pure function getn0(this) result (n)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
            type(AtomSpace),intent(in)              ::      this
            real(kind=real64),dimension(3)          ::      n
            n = this%n
            return
        end function getn0

        pure function geta_super0(this) result (a_super)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            type(AtomSpace),intent(in)           ::      this
            real(kind=real64),dimension(3,3)          ::      a_super
            a_super = this%a_super
            return
        end function geta_super0

        pure function getR0(this) result (R)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
            type(AtomSpace),intent(in)           ::      this
            real(kind=real64),dimension(3,3)          ::      R
            R = this%R
            return
        end function getR0


        pure subroutine seta_super0(this,a_super)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*      sets the periodic supercell sides, and the normal to the foil before rotation
            type(AtomSpace),intent(inout)                       ::      this
            real(kind=real64),dimension(3,3),intent(in)         ::      a_super

            this%a_super = a_super

        !---    normal before rotation
            this%n0(1:3) = (/ this%a_super(2,1)*this%a_super(3,2) - this%a_super(3,1)*this%a_super(2,2)     &
                            ,this%a_super(3,1)*this%a_super(1,2) - this%a_super(1,1)*this%a_super(3,2)     &
                            ,this%a_super(1,1)*this%a_super(2,2) - this%a_super(2,1)*this%a_super(1,2)      /)
            this%n0 = this%n0 / norm2(this%n0)

            return
        end subroutine seta_super0

        pure subroutine setR0(this,R)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*      sets the rotation matrix, and the normal to the foil after rotation. 
    !*      note that this works out the change in thickness of the planes, but then uses this to modify the thickness this%L which may have been set by atom positions.        
            type(AtomSpace),intent(inout)                       ::      this
            real(kind=real64),dimension(3,3),intent(in)         ::      R

            real(kind=real64)                   ::          L_before,L_after
            real(kind=real64),dimension(3,3)    ::          dR
            L_before = getThickness(this)

            this%R = R
            
        !---    normal after rotation
            this%n(1:3) = this%R(1:3,1)*this%n0(1) + this%R(1:3,2)*this%n0(2) + this%R(1:3,3)*this%n0(3) 

            dR = matmul( R,transpose(this%R) )
            L_after = getThickness(this,dR)
            if (L_before > 0) this%L = this%L * L_after / L_before
            return
        end subroutine setR0


        pure subroutine setDelta0(this,Nx,Ny,Nz)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*      given the imaging space size, compute displacmeent required so atom in middle of box is in middle of imaging space
    !*      The atoms are input at positions r = xyzoffset + a_super [xyz], with [xyz] in range 0:1
    !*      they are scaled and transformed to 
    !*          rt = R ( r - delta )/a
    !*      return delta such that an atom in the centre of the xyz file ends up at the centre of the imaging space.
    !*          R( off + (a1+a2+a3)/2 - delta )/a = [Nx,Ny,Nz]/2
    !*          delta = off + (a1+a2+a3)/2 - a R^T [Nx,Ny,Nz]/2 
    !*      
            type(AtomSpace),intent(inout)                       ::      this
            integer,intent(in)                                  ::      Nx,Ny,Nz
 
            this%delta(1:3) = this%R(1,1:3)*Nx + this%R(2,1:3)*Ny + this%R(3,1:3)*Nz            !   R^T [Nx,Ny,Nz]
            this%delta(1:3) = this%xyzoffset(1:3) + (this%a_super(1:3,1)+this%a_super(1:3,2)+this%a_super(1:3,3))/2 - this%delta(1:3)/(2*this%ia)

            return
        end subroutine setDelta0


        pure real(kind=real64) function getThickness0(this)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
            type(AtomSpace),intent(in)                              ::      this
            real(kind=real64),dimension(3)              ::      nn      !   new normal
            real(kind=real64)                           ::      a3dotn0 
            
            nn(1:3) = this%R(1:3,1)*this%n0(1) + this%R(1:3,2)*this%n0(2) + this%R(1:3,3)*this%n0(3) 

            a3dotn0 = dot_product( this%a_super(1:3,3) , this%n0 )  
            getThickness0 = a3dotn0/nn(3)
            !getThickness0 = this%L
            return
        end function getThickness0


        pure real(kind=real64) function getThickness1(this,R)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*      compute the foil thickness assuming a further virtual tilt by R
    !*      note that this works out the change in thickness of the planes, but then actually computes using this%L which may have been set by atom positions.
            type(AtomSpace),intent(in)                              ::      this
            real(kind=real64),dimension(3,3),intent(in)             ::      R

            real(kind=real64),dimension(3,3)            ::      RR      !   new rotation
            real(kind=real64),dimension(3)              ::      nn      !   new normal
            real(kind=real64)                           ::      a3dotn0 
            real(kind=real64)                   ::          L_before,L_after

            L_before = getThickness(this)
            RR = matmul(R,this%R)
            nn(1:3) = RR(1:3,1)*this%n0(1) + RR(1:3,2)*this%n0(2) + RR(1:3,3)*this%n0(3) 

            a3dotn0 = dot_product( this%a_super(1:3,3) , this%n0 )  
            L_after = a3dotn0/nn(3)
            
            getThickness1 = this%L * L_after / L_before
            return
        end function getThickness1

        subroutine setThickness(this,r)
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    !*      given the rotation matrix, compute the bounds of the foil thickness and the thickness in the imaging z- direction
    !*      atom positions after periodic copies are 
    !*          rt = R ( rj - delta + m a1 + n a2 )/a       , with a1,a2 the supercell repeat vectors in x- y- directions
    !*      the normal to the foil is
    !*          n = R( a1 x a2 )
    !*      so 
    !*          rt.n = R( rj - delta ).n / a
    !*
    !*      note that R,n should be set before this call ( see setR0() )
            type(AtomSpace),intent(inout)                           ::      this
            real(kind=real64),dimension(:,:),intent(in),optional    ::      r       !   (3,nAtoms) if present, then use atom positions, otherwise estimate using corners of box
            
            real(kind=real64)                           ::      offdotn0,a3dotn0,rdotn0
            integer,dimension(:),allocatable            ::      atomCountSlice      !   atom count as function of depth in n direction
            integer             ::      nAtoms
            integer             ::      ii,iz
            real(kind=real64)   ::      rho,vol,d1,d2
            real(kind=real64),dimension(3)      ::      nn          

        !   If we have just the corners of the box, rj = f + x a1 + y a2 + z a3
        !   with f the file offset, and (x,y,z) in [0,1)
        !   so rt.n = (R rj).(R n0) = rj.n0 =  = f.n0 + z a3.n0
            offdotn0 = dot_product( this%xyzoffset-this%delta , this%n0 )
            a3dotn0 = dot_product( this%a_super(1:3,3) , this%n0 )  

            if (a3dotn0>0) then      !   should always be, right?
                d1 = ( offdotn0 )*this%ia
                d2 = ( offdotn0 + a3dotn0 )*this%ia
            else
                d1 = ( offdotn0 + a3dotn0 )*this%ia
                d2 = ( offdotn0 )*this%ia
            end if
        
        !   thickness of the foil in the imaging direction is trivial, (d2-d1) = L cos(theta) = L n.z
            this%L = a3dotn0/this%n(3)



            if (present(r)) then
                !   find the atom density as a function of projection on n.
                !   use this to find the point where atom density falls to 25%.

            !---    count the atoms on each slice
                nAtoms = size(r,dim=2)
                allocate( atomCountSlice( floor(d1):ceiling(d2) ))                    !   the distance d2 - d1 is the number of imaging space layers covered by the atoms. 
                atomCountSlice = 0
                do ii = 1,nAtoms
                    rdotn0 = r(1,ii)*this%n0(1) + r(2,ii)*this%n0(2) + r(3,ii)*this%n0(3) 
                    iz = nint( rdotn0*this%ia )                                                 !   which slice to add to
                    atomCountSlice(iz) = atomCountSlice(iz) + 1                                 !   add atom to slice
                end do

            !---    compute the expected number of atoms on each slice
                nn = (/ this%a_super(2,1)*this%a_super(3,2) - this%a_super(3,1)*this%a_super(2,2)                       &       !   unnormalised vector normal to a1,a2 plane
                       ,this%a_super(3,1)*this%a_super(1,2) - this%a_super(1,1)*this%a_super(3,2)                       &
                       ,this%a_super(1,1)*this%a_super(2,2) - this%a_super(2,1)*this%a_super(1,2)      /) 
                vol = this%a_super(1,3)*nn(1) + this%a_super(2,3)*nn(2) + this%a_super(3,3)*nn(3)                       !   volume of supercell
                rho = nAtoms / ( vol * this%ia * a3dotn0 )                                                          !   expected count per slice, assuming homogeneous atom distribution

            !---    find the first slice where the expected number passes 1/4 the expected number
                do iz = lbound(atomCountSlice,dim=1),ubound(atomCountSlice,dim=1)
                    if (atomCountSlice(iz)*4 >= rho) then
                        d1 = iz         
                        exit
                    end if
                end do

            !---    find the last slice where the expected number passes 1/4 the expected number
                do iz = ubound(atomCountSlice,dim=1),lbound(atomCountSlice,dim=1),-1
                    if (atomCountSlice(iz)*4 >= rho) then
                        d2 = iz  
                        exit
                    end if
                end do                
                        
            !   thickness of the foil in the imaging direction is trivial, (d2-d1) = L cos(theta) = L n.z
                this%L = (d2-d1)/this%n(3)
 

            end if

            return
        end subroutine setThickness


            
        subroutine Lib_AtomSpace_init_MPI()
    !---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ 
#ifdef MPI
            integer             ::      ierror
            logical             ::      ok
            call MPI_Initialized(ok,ierror)
            if (.not. ok) call MPI_INIT(ierror)
            call MPI_COMM_SIZE(MPI_COMM_WORLD, nProcs, ierror)
            call MPI_COMM_RANK(MPI_COMM_WORLD, rank, ierror)
            if (rank == 0) print *,"Lib_AtomSpace::Lib_AtomSpace_init_MPI info - initialised with ",nProcs," processes"  
#else
            print *,"Lib_AtomSpace::Lib_AtomSpace_init_MPI info - serial mode"  
#endif            
            return
        end subroutine Lib_AtomSpace_init_MPI

                       
            
    end module Lib_AtomSpace